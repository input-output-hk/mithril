#include <gtest/gtest.h>
extern "C" {
#include "../target/include/mithril.h"
}

TEST(atm, produceAndVerifyAggregateSignature) {
    const char *msg = "some message";

    // Test with 5 parties, each with stake = 1, which is equivalent to a setting where one signer has one
    // vote. And let the threshold be 4.
    PartyId party_ids[5] = {1, 2, 3, 4, 5};
    Stake party_stake[5] = {1, 1, 1, 1, 1};
    MspPkPtr keys[5];
    MspSkPtr sks[5];
    unsigned int nr_signers = 5;
    unsigned int threshold = 4;

    for (int i = 0; i < nr_signers; i++) {
        msp_generate_keypair(&sks[i], &keys[i]);
    }

    // The threshold public key can be generated by using the public key parts of the participants.
    AvkPtr avk_pk;

    ASSERT_EQ(avk_key_aggregation(keys, party_stake, nr_signers, threshold, &avk_pk), 0);

    // Now, signers can produce threshold signatures with respect to `avk_pk`. Now, let's assume that
    // parties 0-3 generate a signature.
    MspSigPtr sigs[4];

    for (int i = 0; i < 4; i++) {
        sigs[i] = msp_sign(msg, sks[i]);
    }

    // Given the four signatures and the public keys from the corresponding signers, any third party (not necessarily
    // a signer) can aggregate the signatures. It only needs knowledge of the avk key over which it is supposed to be
    // valid.
    AsigPtr aggregated_sig = atms_aggregate_sigs(sigs, keys, avk_pk, 4);

    // Finally, we check that the signature is indeed valid.
    ASSERT_EQ(atms_verify_sig(msg, aggregated_sig, avk_pk), 0);
}

TEST(atm, testingErrors) {
    const char *msg = "some message";

    // Test with 5 parties and set the threshold to 4.
    PartyId party_ids[5] = {1, 2, 3, 4, 5};
    Stake party_stake[5] = {1, 1, 1, 1, 1};
    MspPkPtr keys[5];
    MspSkPtr sks[5];
    unsigned int nr_signers = 5;
    unsigned int threshold = 3;

    for (int i = 0; i < nr_signers; i++) {
        msp_generate_keypair(&sks[i], &keys[i]);
    }

    // We also create keys which will not be registered
    MspPkPtr fake_key;
    MspSkPtr fake_skey;
    msp_generate_keypair(&fake_skey, &fake_key);

    // The threshold public key can be generated by using the public key parts of the participants. We leave out of this
    // the key of the "fake" party.
    AvkPtr avk_pk;
    ASSERT_EQ(avk_key_aggregation(keys, party_stake, nr_signers, threshold, &avk_pk), 0);

    // We also create a "fake" avk;
    AvkPtr avk_pk_fake;
    ASSERT_EQ(avk_key_aggregation(keys, party_stake, 3, 2, &avk_pk_fake), 0);

    // Now, signers can produce threshold signatures with respect to `avk_pk`. Now, let's assume that
    // only 0-3 generate a signature.
    MspSigPtr sigs[3];

    for (int i = 0; i < 3; i++) {
        sigs[i] = msp_sign(msg, sks[i]);
    }

    // We also create the fake signature
    MspSigPtr sig_fake = msp_sign(msg, fake_skey);

    // First we create a signature with no sufficient signers.
    AsigPtr aggregated_sig_1 = atms_aggregate_sigs(sigs, keys, avk_pk, 2);
    ASSERT_EQ(atms_verify_sig(msg, aggregated_sig_1, avk_pk), -1);


    // Now we create a signature with four keys, but verify it over `avk_pk_fake`, that only contains 3. We should
    // get error -4 as key nr 4 is not part of `avk_pk_fake`.
    AsigPtr aggregated_sig_2 = atms_aggregate_sigs(sigs, keys, avk_pk, 4);
    ASSERT_EQ(atms_verify_sig(msg, aggregated_sig_2, avk_pk_fake), -4);

    // Finally, if we set pk[3] = fake_key, and sig[3] = sig_fake, we'll get an invalid verification over public key
    // avk_pk, even if we have sufficient signers.
    keys[1] = fake_key;
    AsigPtr aggregated_sig_3 = atms_aggregate_sigs(sigs, keys, avk_pk, 4);
    ASSERT_EQ(atms_verify_sig(msg, aggregated_sig_2, avk_pk), -5);
}
