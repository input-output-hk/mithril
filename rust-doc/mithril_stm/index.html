<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Mithril-stm CI workflow crates.io License Discord"><title>mithril_stm - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="mithril_stm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../mithril_stm/index.html">mithril_<wbr>stm</a><span class="version">0.5.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#mithril-stm-ci-workflow-cratesio-license-discord" title="Mithril-stm CI workflow crates.io License Discord">Mithril-stm CI workflow crates.io License Discord</a><ul><li><a href="#pre-requisites" title="Pre-requisites">Pre-requisites</a></li><li><a href="#download-source-code" title="Download source code">Download source code</a></li><li><a href="#compiling-the-library" title="Compiling the library">Compiling the library</a></li><li><a href="#running-the-tests" title="Running the tests">Running the tests</a></li><li><a href="#running-the-benches" title="Running the benches">Running the benches</a></li><li><a href="#example" title="Example">Example</a></li><li><a href="#benchmarks" title="Benchmarks">Benchmarks</a></li></ul></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>mithril_stm</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/mithril_stm/lib.rs.html#1-191">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="mithril-stm-ci-workflow-cratesio-license-discord"><a class="doc-anchor" href="#mithril-stm-ci-workflow-cratesio-license-discord">§</a>Mithril-stm <a href="https://github.com/input-output-hk/mithril/actions/workflows/ci.yml"><img src="https://github.com/input-output-hk/mithril/actions/workflows/ci.yml/badge.svg" alt="CI workflow" /></a> <a href="https://crates.io/crates/mithril-stm"><img src="https://img.shields.io/crates/v/mithril-stm.svg" alt="crates.io" /></a> <a href="https://github.com/input-output-hk/mithril/blob/main/LICENSE"><img src="https://img.shields.io/badge/license-Apache%202.0-blue?style=flat-square" alt="License" /></a> <a href="https://discord.gg/5kaErDKDRq"><img src="https://img.shields.io/discord/500028886025895936.svg?logo=discord&amp;style=flat-square" alt="Discord" /></a></h2>
<p><strong>This is a work in progress</strong> 🛠</p>
<ul>
<li>
<p><code>mithril-stm</code> is a Rust implementation of the scheme described in the paper <a href="https://eprint.iacr.org/2021/916.pdf">Mithril: Stake-based Threshold Multisignatures</a> by Pyrros Chaidos and Aggelos Kiayias.</p>
</li>
<li>
<p>The BLS12-381 signature library <a href="https://github.com/supranational/blst">blst</a> is used as the backend for the implementation of STM.</p>
</li>
<li>
<p>This implementation supports the <em>trivial concatenation proof system</em> (Section 4.3). Other proof systems such as <em>Bulletproofs</em> or <em>Halo2</em> are not supported in this version.</p>
</li>
<li>
<p>We implemented the concatenation proof system as batch proofs:</p>
<ul>
<li>Individual signatures do not contain the Merkle path to prove membership of the avk. Instead, it is the role of the aggregator to generate such proofs. This allows for a more efficient implementation of batched membership proofs (or batched Merkle paths).</li>
</ul>
</li>
<li>
<p>Protocol documentation is given in <a href="https://mithril.network/doc/mithril/mithril-protocol/protocol/">Mithril Protocol in depth</a>.</p>
</li>
<li>
<p>The API also includes <em>core verification</em>. This functionality allows a full node verifier (<code>CoreVerifier</code>) that is
able to verify the signatures that are generated without the registration information, i.e., <code>avk</code>. A
<code>CoreVerifier</code> is assumed to know identities of the signers, so, it does not need to check the registration.</p>
</li>
<li>
<p>This library provides:</p>
<ul>
<li>The implementation of the Stake-based Threshold Multisignatures</li>
<li>The implementation of <code>CoreVerifier</code></li>
<li>Key registration procedure for STM signatures</li>
<li>The tests for the library functions, STM scheme, and <code>CoreVerifier</code></li>
<li>Benchmark tests</li>
</ul>
</li>
</ul>
<h3 id="pre-requisites"><a class="doc-anchor" href="#pre-requisites">§</a>Pre-requisites</h3>
<p><strong>Install Rust</strong></p>
<ul>
<li>
<p>Install a <a href="https://www.rust-lang.org/learn/get-started">correctly configured</a> Rust toolchain (latest stable version).</p>
</li>
<li>
<p>Install Build Tools <code>build-essential</code> and <code>m4</code>. For example, on Ubuntu/Debian/Mint, run <code>sudo apt install build-essential m4</code>.</p>
</li>
</ul>
<h3 id="download-source-code"><a class="doc-anchor" href="#download-source-code">§</a>Download source code</h3><div class="example-wrap"><pre class="language-bash"><code># Download sources from github
git clone https://github.com/input-output-hk/mithril

# Go to sources directory
cd mithril-stm</code></pre></div><h3 id="compiling-the-library"><a class="doc-anchor" href="#compiling-the-library">§</a>Compiling the library</h3><div class="example-wrap"><pre class="language-shell"><code>cargo build --release</code></pre></div><h3 id="running-the-tests"><a class="doc-anchor" href="#running-the-tests">§</a>Running the tests</h3>
<p>For running rust tests, simply run (to run the tests faster, the use of <code>--release</code> flag is recommended):</p>
<div class="example-wrap"><pre class="language-shell"><code>cargo test --release</code></pre></div><h3 id="running-the-benches"><a class="doc-anchor" href="#running-the-benches">§</a>Running the benches</h3><div class="example-wrap"><pre class="language-shell"><code>cargo bench</code></pre></div><h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<p>The following is a simple example of the STM implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>blake2::{digest::consts::U32, Blake2b};
<span class="kw">use </span>rand_chacha::ChaCha20Rng;
<span class="kw">use </span>rand_core::{RngCore, SeedableRng};
<span class="kw">use </span>rayon::prelude::<span class="kw-2">*</span>;

<span class="kw">use </span>mithril_stm::{
    AggregateSignatureType, AggregationError, Clerk, Initializer, KeyRegistration, Parameters,
    Signer, SingleSignature,
};

<span class="kw">type </span>H = Blake2b&lt;U32&gt;;

<span class="kw">let </span>nparties = <span class="number">32</span>;
<span class="kw">let </span><span class="kw-2">mut </span>rng = ChaCha20Rng::from_seed([<span class="number">0u8</span>; <span class="number">32</span>]);
<span class="kw">let </span><span class="kw-2">mut </span>msg = [<span class="number">0u8</span>; <span class="number">16</span>];
rng.fill_bytes(<span class="kw-2">&amp;mut </span>msg);

<span class="comment">//////////////////////////
// initialization phase //
//////////////////////////

</span><span class="kw">let </span>params = Parameters {
    k: <span class="number">357</span>,
    m: <span class="number">2642</span>,
    phi_f: <span class="number">0.2</span>,
};

<span class="kw">let </span>parties = (<span class="number">0</span>..nparties)
    .into_iter()
    .map(|<span class="kw">_</span>| <span class="number">1 </span>+ (rng.next_u64() % <span class="number">9999</span>))
    .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

<span class="kw">let </span><span class="kw-2">mut </span>key_reg = KeyRegistration::init();

<span class="kw">let </span><span class="kw-2">mut </span>ps: Vec&lt;Initializer&gt; = Vec::with_capacity(nparties <span class="kw">as </span>usize);
<span class="kw">for </span>stake <span class="kw">in </span>parties {
    <span class="kw">let </span>p = Initializer::new(params, stake, <span class="kw-2">&amp;mut </span>rng);
    key_reg.register(stake, p.get_verification_key_proof_of_possession()).unwrap();
    ps.push(p);
}

<span class="kw">let </span>closed_reg = key_reg.close();

<span class="kw">let </span>ps = ps
    .into_par_iter()
    .map(|p| p.create_signer(closed_reg.clone()).unwrap())
    .collect::&lt;Vec&lt;Signer&lt;H&gt;&gt;&gt;();

<span class="comment">/////////////////////
// operation phase //
/////////////////////

</span><span class="kw">let </span>sigs = ps
    .par_iter()
    .filter_map(|p| p.sign(<span class="kw-2">&amp;</span>msg))
    .collect::&lt;Vec&lt;SingleSignature&gt;&gt;();

<span class="kw">let </span>clerk = Clerk::new_clerk_from_signer(<span class="kw-2">&amp;</span>ps[<span class="number">0</span>]);
<span class="kw">let </span>avk = clerk.compute_aggregate_verification_key();

<span class="comment">// Check all parties can verify every sig
</span><span class="kw">for </span>(s, p) <span class="kw">in </span>sigs.iter().zip(ps.iter()) {
    <span class="macro">assert!</span>(s.verify(<span class="kw-2">&amp;</span>params, <span class="kw-2">&amp;</span>p.get_verification_key(), <span class="kw-2">&amp;</span>p.get_stake(), <span class="kw-2">&amp;</span>avk, <span class="kw-2">&amp;</span>msg).is_ok(), <span class="string">"Verification
    failed"</span>);
}

<span class="comment">// Aggregate a concatenation proof with random parties
</span><span class="kw">let </span>msig = clerk.aggregate_signatures_with_type(<span class="kw-2">&amp;</span>sigs, <span class="kw-2">&amp;</span>msg, AggregateSignatureType::Concatenation);

<span class="kw">match </span>msig {
    <span class="prelude-val">Ok</span>(aggr) =&gt; {
        <span class="macro">println!</span>(<span class="string">"Aggregate ok"</span>);
        <span class="macro">assert!</span>(aggr.verify(<span class="kw-2">&amp;</span>msg, <span class="kw-2">&amp;</span>clerk.compute_aggregate_verification_key(), <span class="kw-2">&amp;</span>params).is_ok());
    }
    <span class="prelude-val">Err</span>(AggregationError::NotEnoughSignatures(n, k)) =&gt; {
        <span class="macro">println!</span>(<span class="string">"Not enough signatures"</span>);
        <span class="macro">assert!</span>(n &lt; params.k &amp;&amp; k == params.k)
    }
    <span class="prelude-val">Err</span>(AggregationError::UsizeConversionInvalid) =&gt; {
        <span class="macro">println!</span>(<span class="string">"Invalid usize conversion"</span>);
    }
    <span class="prelude-val">Err</span>(AggregationError::UnsupportedProofSystem(aggregate_signature_type)) =&gt; {
        <span class="macro">println!</span>(<span class="string">"Unsupported proof system: {:?}"</span>, aggregate_signature_type);
    }
}</code></pre></div>
<h3 id="benchmarks"><a class="doc-anchor" href="#benchmarks">§</a>Benchmarks</h3>
<p>Here we give the benchmark results of STM for size and time. We run the benchmarks on macOS 12.6 on an Apple M1 Pro machine with 16 GB of RAM.</p>
<p>Note that the size of an individual signature with one valid index is <strong>72 bytes</strong> (48 bytes from <code>sigma</code>, 8 bytes from <code>party_index</code>, 8 bytes for the <code>length</code> of winning indices and at least 8 bytes for a single winning <code>index</code>) and increases linearly in the length of valid indices (where an index is 8 bytes).</p>
<div class="example-wrap"><pre class="language-shell"><code>+----------------------+
| Size of benchmarks   |
+----------------------+
| Results obtained by using the parameters suggested by the paper.
+----------------------+
+----------------------+
| Aggregate signatures |
+----------------------+
+----------------------+
| Hash: Blake2b 512    |
+----------------------+
k = 445 | m = 2728 | nr parties = 3000; 118760 bytes
+----------------------+
| Hash: Blake2b 256    |
+----------------------+
k = 445 | m = 2728 | nr parties = 3000; 99384 bytes
+----------------------+
+----------------------+
| Aggregate signatures |
+----------------------+
| Hash: Blake2b 512    |
+----------------------+
k = 554 | m = 3597 | nr parties = 3000; 133936 bytes
+----------------------+
| Hash: Blake2b 256    |
+----------------------+
k = 554 | m = 3597 | nr parties = 3000; 113728 bytes</code></pre></div><div class="example-wrap"><pre class="language-shell"><code>STM/Blake2b/Key registration/k: 25, m: 150, nr_parties: 300
                        time:   [409.70 ms 426.81 ms 446.30 ms]
STM/Blake2b/Play all lotteries/k: 25, m: 150, nr_parties: 300
                        time:   [696.58 µs 697.62 µs 698.75 µs]
STM/Blake2b/Aggregation/k: 25, m: 150, nr_parties: 300
                        time:   [18.765 ms 18.775 ms 18.785 ms]
STM/Blake2b/Verification/k: 25, m: 150, nr_parties: 300
                        time:   [2.1577 ms 2.1715 ms 2.1915 ms]

STM/Blake2b/Key registration/k: 250, m: 1523, nr_parties: 2000
                        time:   [2.5807 s 2.5880 s 2.5961 s]
STM/Blake2b/Play all lotteries/k: 250, m: 1523, nr_parties: 2000
                        time:   [5.9318 ms 5.9447 ms 5.9582 ms]
STM/Blake2b/Aggregation/k: 250, m: 1523, nr_parties: 2000
                        time:   [190.81 ms 191.15 ms 191.54 ms]
STM/Blake2b/Verification/k: 250, m: 1523, nr_parties: 2000
                        time:   [13.944 ms 14.010 ms 14.077 ms]</code></pre></div>
<p>Implementation of Stake-based Threshold Multisignatures
Top-level API for Mithril Stake-based Threshold Multisignature scheme.
See figure 6 of <a href="https://eprint.iacr.org/2021/916">the paper</a> for most of the
protocol.</p>
<p>What follows is a simple example showing the usage of STM.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>blake2::{Blake2b, digest::consts::U32};
<span class="kw">use </span>rand_chacha::ChaCha20Rng;
<span class="kw">use </span>rand_core::{RngCore, SeedableRng};
<span class="kw">use </span>rayon::prelude::<span class="kw-2">*</span>; <span class="comment">// We use par_iter to speed things up

</span><span class="kw">use </span>mithril_stm::{
   AggregateSignatureType, AggregationError, Clerk, Initializer, KeyRegistration, Parameters,
   Signer, SingleSignature,
};

<span class="kw">let </span>nparties = <span class="number">4</span>; <span class="comment">// Use a small number of parties for this example
</span><span class="kw">type </span>D = Blake2b&lt;U32&gt;; <span class="comment">// Setting the hash function for convenience

</span><span class="kw">let </span><span class="kw-2">mut </span>rng = ChaCha20Rng::from_seed([<span class="number">0u8</span>; <span class="number">32</span>]); <span class="comment">// create and initialize rng
</span><span class="kw">let </span><span class="kw-2">mut </span>msg = [<span class="number">0u8</span>; <span class="number">16</span>]; <span class="comment">// setting an arbitrary message
</span>rng.fill_bytes(<span class="kw-2">&amp;mut </span>msg);

<span class="comment">// In the following, we will have 4 parties try to sign `msg`, then aggregate and
// verify those signatures.

//////////////////////////
// initialization phase //
//////////////////////////

// Set low parameters for testing
// XXX: not for production
</span><span class="kw">let </span>params = Parameters {
    m: <span class="number">100</span>, <span class="comment">// Security parameter XXX: not for production
    </span>k: <span class="number">2</span>, <span class="comment">// Quorum parameter XXX: not for production
    </span>phi_f: <span class="number">0.2</span>, <span class="comment">// Lottery parameter XXX: not for production
</span>};

<span class="comment">// Generate some arbitrary stake for each party
// Stake is an integer.
// Total stake of all parties is total stake in the system.
</span><span class="kw">let </span>stakes = (<span class="number">0</span>..nparties)
    .into_iter()
    .map(|<span class="kw">_</span>| <span class="number">1 </span>+ (rng.next_u64() % <span class="number">9999</span>))
    .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

<span class="comment">// Create a new key registry from the parties and their stake
</span><span class="kw">let </span><span class="kw-2">mut </span>key_reg = KeyRegistration::init();

<span class="comment">// For each party, crate a Initializer.
// This struct can create keys for the party.
</span><span class="kw">let </span><span class="kw-2">mut </span>ps: Vec&lt;Initializer&gt; = Vec::with_capacity(nparties);
<span class="kw">for </span>stake <span class="kw">in </span>stakes {
    <span class="comment">// Create keys for this party
    </span><span class="kw">let </span>p = Initializer::new(params, stake, <span class="kw-2">&amp;mut </span>rng);
    <span class="comment">// Register keys with the KeyRegistration service
    </span>key_reg
        .register(p.stake, p.verification_key())
        .unwrap();
    ps.push(p);
}

<span class="comment">// Close the key registration.
</span><span class="kw">let </span>closed_reg = key_reg.close();

<span class="comment">// Finalize the Initializer and turn it into a Signer, which can execute the
// rest of the protocol.
</span><span class="kw">let </span>ps = ps
    .into_par_iter()
    .map(|p| p.new_signer(closed_reg.clone()).unwrap())
    .collect::&lt;Vec&lt;Signer&lt;D&gt;&gt;&gt;();

<span class="comment">/////////////////////
// operation phase //
/////////////////////

// Next, each party tries to sign the message for each index available.
// We collect the successful signatures into a vec.
</span><span class="kw">let </span>sigs = ps
    .par_iter()
    .filter_map(|p| {
        <span class="kw">return </span>p.sign(<span class="kw-2">&amp;</span>msg);
    })
    .collect::&lt;Vec&lt;SingleSignature&gt;&gt;();

<span class="comment">// Clerk can aggregate and verify signatures.
</span><span class="kw">let </span>clerk = Clerk::from_signer(<span class="kw-2">&amp;</span>ps[<span class="number">0</span>]);

<span class="comment">// Aggregate and verify the signatures
</span><span class="kw">let </span>msig = clerk.aggregate(<span class="kw-2">&amp;</span>sigs, <span class="kw-2">&amp;</span>msg);
<span class="kw">match </span>msig {
    <span class="prelude-val">Ok</span>(aggr) =&gt; {
        <span class="macro">println!</span>(<span class="string">"Aggregate ok"</span>);
        <span class="macro">assert!</span>(aggr
            .verify(<span class="kw-2">&amp;</span>msg, <span class="kw-2">&amp;</span>clerk.compute_avk(), <span class="kw-2">&amp;</span>params)
            .is_ok());
    }
    <span class="prelude-val">Err</span>(AggregationError::NotEnoughSignatures(n, k)) =&gt; {
        <span class="macro">println!</span>(<span class="string">"Not enough signatures"</span>);
        <span class="macro">assert!</span>(n &lt; params.k &amp;&amp; k == params.k)
    }
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">unreachable!</span>(),
}</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AggregateVerificationKey.html" title="struct mithril_stm::AggregateVerificationKey">Aggregate<wbr>Verification<wbr>Key</a></dt><dd>Stm aggregate key (batch compatible), which contains the merkle tree commitment and the total stake of the system.
Batch Compat Merkle tree commitment includes the number of leaves in the tree in order to obtain batch path.</dd><dt><a class="struct" href="struct.BasicVerifier.html" title="struct mithril_stm::BasicVerifier">Basic<wbr>Verifier</a></dt><dd>Full node verifier including the list of eligible signers and the total stake of the system.</dd><dt><a class="struct" href="struct.BlsProofOfPossession.html" title="struct mithril_stm::BlsProofOfPossession">BlsProof<wbr>OfPossession</a></dt><dd>MultiSig proof of possession, which contains two elements from G1. However,
the two elements have different types: <code>k1</code> is represented as a BlstSig
as it has the same structure, and this facilitates its verification. On
the other hand, <code>k2</code> is a G1 point, as it does not share structure with
the BLS signature, and we need to have an ad-hoc verification mechanism.</dd><dt><a class="struct" href="struct.BlsSignature.html" title="struct mithril_stm::BlsSignature">BlsSignature</a></dt><dd>MultiSig signature, which is a wrapper over the <code>BlstSig</code> type.</dd><dt><a class="struct" href="struct.BlsSigningKey.html" title="struct mithril_stm::BlsSigningKey">BlsSigning<wbr>Key</a></dt><dd>MultiSig secret key, which is a wrapper over the BlstSk type from the blst
library.</dd><dt><a class="struct" href="struct.BlsVerificationKey.html" title="struct mithril_stm::BlsVerificationKey">BlsVerification<wbr>Key</a></dt><dd>MultiSig verification key, which is a wrapper over the BlstVk (element in G2)
from the blst library.</dd><dt><a class="struct" href="struct.BlsVerificationKeyProofOfPossession.html" title="struct mithril_stm::BlsVerificationKeyProofOfPossession">BlsVerification<wbr>KeyProof<wbr>OfPossession</a></dt><dd>MultiSig public key, contains the verification key and the proof of possession.</dd><dt><a class="struct" href="struct.Clerk.html" title="struct mithril_stm::Clerk">Clerk</a></dt><dd><code>Clerk</code> can verify and aggregate <code>SingleSignature</code>s and verify <code>AggregateSignature</code>s.
Clerks can only be generated with the registration closed.
This avoids that a Merkle Tree is computed before all parties have registered.</dd><dt><a class="struct" href="struct.ClosedKeyReg.html" title="struct mithril_stm::ClosedKeyReg">Closed<wbr>KeyReg</a></dt><dd>Structure generated out of a closed registration containing the registered parties, total stake, and the merkle tree.
One can only get a global <code>avk</code> out of a closed key registration.</dd><dt><a class="struct" href="struct.ClosedKeyRegistration.html" title="struct mithril_stm::ClosedKeyRegistration">Closed<wbr>KeyRegistration</a></dt><dd>Structure generated out of a closed registration containing the registered parties, total stake, and the merkle tree.
One can only get a global <code>avk</code> out of a closed key registration.</dd><dt><a class="struct" href="struct.CoreVerifier.html" title="struct mithril_stm::CoreVerifier">Core<wbr>Verifier</a></dt><dd>Full node verifier including the list of eligible signers and the total stake of the system.</dd><dt><a class="struct" href="struct.Initializer.html" title="struct mithril_stm::Initializer">Initializer</a></dt><dd>Initializer for <code>Signer</code>.
This is the data that is used during the key registration procedure.
Once the latter is finished, this instance is consumed into an <code>Signer</code>.</dd><dt><a class="struct" href="struct.KeyReg.html" title="struct mithril_stm::KeyReg">KeyReg</a></dt><dd>Struct that collects public keys and stakes of parties.
Each participant (both the signers and the clerks) need to run their own instance of the key registration.</dd><dt><a class="struct" href="struct.KeyRegistration.html" title="struct mithril_stm::KeyRegistration">KeyRegistration</a></dt><dd>Struct that collects public keys and stakes of parties.
Each participant (both the signers and the clerks) need to run their own instance of the key registration.</dd><dt><a class="struct" href="struct.Parameters.html" title="struct mithril_stm::Parameters">Parameters</a></dt><dd>Used to set protocol parameters.</dd><dt><a class="struct" href="struct.Signer.html" title="struct mithril_stm::Signer">Signer</a></dt><dd>Participant in the protocol can sign messages.</dd><dt><a class="struct" href="struct.SingleSignature.html" title="struct mithril_stm::SingleSignature">Single<wbr>Signature</a></dt><dd>Signature created by a single party who has won the lottery.</dd><dt><a class="struct" href="struct.SingleSignatureWithRegisteredParty.html" title="struct mithril_stm::SingleSignatureWithRegisteredParty">Single<wbr>Signature<wbr>With<wbr>Registered<wbr>Party</a></dt><dd>Signature with its registered party.</dd><dt><a class="struct" href="struct.StmAggrVerificationKey.html" title="struct mithril_stm::StmAggrVerificationKey">StmAggr<wbr>Verification<wbr>Key</a></dt><dd>Stm aggregate key (batch compatible), which contains the merkle tree commitment and the total stake of the system.
Batch Compat Merkle tree commitment includes the number of leaves in the tree in order to obtain batch path.</dd><dt><a class="struct" href="struct.StmClerk.html" title="struct mithril_stm::StmClerk">StmClerk</a></dt><dd><code>Clerk</code> can verify and aggregate <code>SingleSignature</code>s and verify <code>AggregateSignature</code>s.
Clerks can only be generated with the registration closed.
This avoids that a Merkle Tree is computed before all parties have registered.</dd><dt><a class="struct" href="struct.StmInitializer.html" title="struct mithril_stm::StmInitializer">StmInitializer</a></dt><dd>Initializer for <code>Signer</code>.
This is the data that is used during the key registration procedure.
Once the latter is finished, this instance is consumed into an <code>Signer</code>.</dd><dt><a class="struct" href="struct.StmParameters.html" title="struct mithril_stm::StmParameters">StmParameters</a></dt><dd>Used to set protocol parameters.</dd><dt><a class="struct" href="struct.StmSig.html" title="struct mithril_stm::StmSig">StmSig</a></dt><dd>Signature created by a single party who has won the lottery.</dd><dt><a class="struct" href="struct.StmSigRegParty.html" title="struct mithril_stm::StmSigRegParty">StmSig<wbr>RegParty</a></dt><dd>Signature with its registered party.</dd><dt><a class="struct" href="struct.StmSigner.html" title="struct mithril_stm::StmSigner">StmSigner</a></dt><dd>Participant in the protocol can sign messages.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AggregateSignature.html" title="enum mithril_stm::AggregateSignature">Aggregate<wbr>Signature</a></dt><dd>An STM aggregate signature.</dd><dt><a class="enum" href="enum.AggregateSignatureType.html" title="enum mithril_stm::AggregateSignatureType">Aggregate<wbr>Signature<wbr>Type</a></dt><dd>The type of STM aggregate signature.</dd><dt><a class="enum" href="enum.AggregationError.html" title="enum mithril_stm::AggregationError">Aggregation<wbr>Error</a></dt><dd>Error types for aggregation.</dd><dt><a class="enum" href="enum.CoreVerifierError.html" title="enum mithril_stm::CoreVerifierError">Core<wbr>Verifier<wbr>Error</a></dt><dd>Errors which can be output by <code>CoreVerifier</code>.</dd><dt><a class="enum" href="enum.RegisterError.html" title="enum mithril_stm::RegisterError">Register<wbr>Error</a></dt><dd>Errors which can be outputted by key registration.</dd><dt><a class="enum" href="enum.StmAggrSig.html" title="enum mithril_stm::StmAggrSig">StmAggr<wbr>Sig</a></dt><dd>An STM aggregate signature.</dd><dt><a class="enum" href="enum.StmAggregateSignatureError.html" title="enum mithril_stm::StmAggregateSignatureError">StmAggregate<wbr>Signature<wbr>Error</a></dt><dd>Errors which can be output by Mithril aggregate verification.</dd><dt><a class="enum" href="enum.StmSignatureError.html" title="enum mithril_stm::StmSignatureError">StmSignature<wbr>Error</a></dt><dd>Errors which can be output by Mithril single signature verification.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Index.html" title="type mithril_stm::Index">Index</a></dt><dd>Quorum index for signatures.
An aggregate signature (<code>StmMultiSig</code>) must have at least <code>k</code> unique indices.</dd><dt><a class="type" href="type.Stake.html" title="type mithril_stm::Stake">Stake</a></dt><dd>The quantity of stake held by a party, represented as a <code>u64</code>.</dd><dt><a class="type" href="type.StmVerificationKey.html" title="type mithril_stm::StmVerificationKey">StmVerification<wbr>Key</a></dt><dd>Wrapper of the MultiSignature Verification key</dd><dt><a class="type" href="type.StmVerificationKeyPoP.html" title="type mithril_stm::StmVerificationKeyPoP">StmVerification<wbr>KeyPoP</a></dt><dd>Wrapper of the MultiSignature Verification key with proof of possession</dd><dt><a class="type" href="type.VerificationKey.html" title="type mithril_stm::VerificationKey">Verification<wbr>Key</a></dt><dd>Wrapper of the MultiSignature Verification key</dd><dt><a class="type" href="type.VerificationKeyProofOfPossession.html" title="type mithril_stm::VerificationKeyProofOfPossession">Verification<wbr>KeyProof<wbr>OfPossession</a></dt><dd>Wrapper of the MultiSignature Verification key with proof of possession</dd></dl></section></div></main></body></html>