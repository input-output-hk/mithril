searchState.loadedDescShard("mithril_stm", 0, "Mithril-stm CI workflow crates.io License Discord\nAn STM aggregate signature.\nThe aggregated signature is invalid\nThe type of STM aggregate signature.\nStm aggregate key (batch compatible), which contains the …\nError types for aggregation.\nFull node verifier including the list of eligible signers …\nBatch verification of STM signatures failed\nBatch verification of STM aggregate signatures failed\nMultiSig proof of possession, which contains two elements …\nMultiSig signature, which is a wrapper over the <code>BlstSig</code> …\nMultiSig secret key, which is a wrapper over the BlstSk …\nMultiSig verification key, which is a wrapper over the …\nMultiSig public key, contains the verification key and the …\n<code>Clerk</code> can verify and aggregate <code>SingleSignature</code>s and verify …\nStructure generated out of a closed registration …\nStructure generated out of a closed registration …\nConcatenation proof system.\nConcatenation proof system.\nConcatenation proof system.\n<code>CoreVerifier</code> check failed\nFull node verifier including the list of eligible signers …\nErrors which can be output by <code>CoreVerifier</code>.\nMSP.Eval was computed incorrectly\nFuture proof system. Not suitable for production.\nA future proof system.\nA future proof system.\nQuorum index for signatures. An aggregate signature (…\nThere is an index out of bounds\nThere is a duplicate index\nOne of the aggregated signatures is invalid\nInitializer for <code>Signer</code>. This is the data that is used …\nThe IVK is invalid after aggregating the keys\nThe supplied key is not valid\nStruct that collects public keys and stakes of parties. …\nThis key has already been registered by a participant\nStruct that collects public keys and stakes of parties. …\nThe lottery was actually lost for the signature\nNo quorum was found\nNot enough signatures were collected, got this many …\nUsed to set protocol parameters.\nInvalid merkle batch path\nErrors which can be outputted by key registration.\nThis error occurs when the the serialization of the raw …\nThis error occurs when the the serialization of the raw …\nSerialization error\nA party submitted an invalid signature\nParticipant in the protocol can sign messages.\nSignature created by a single party who has won the …\nSignature with its registered party.\nThe quantity of stake held by a party, represented as a <code>u64</code>…\nAn STM aggregate signature.\nStm aggregate key (batch compatible), which contains the …\nErrors which can be output by Mithril aggregate …\n<code>Clerk</code> can verify and aggregate <code>SingleSignature</code>s and verify …\nInitializer for <code>Signer</code>. This is the data that is used …\nUsed to set protocol parameters.\nSignature created by a single party who has won the …\nSignature with its registered party.\nErrors which can be output by Mithril single signature …\nParticipant in the protocol can sign messages.\nWrapper of the MultiSignature Verification key\nWrapper of the MultiSignature Verification key with proof …\nUnregisteredInitializer error\nThe proof system used in the aggregate signature is not …\nThe proof system used in the aggregate signature is not …\nThis error happens when we try to convert a u64 to a usize …\nWrapper of the MultiSignature Verification key\nVerification key is the infinity\nWrapper of the MultiSignature Verification key with proof …\nAggregate a set of signatures for their corresponding …\nAggregate a slice of verification keys and Signatures by …\nAggregate a set of signatures.\nAggregate a set of signatures with a given proof type.\nA basic signature generated without closed key …\nBatch verify a set of aggregate signatures\nBatch verify several sets of signatures with their …\nif <code>e(k1,g2) = e(H_G1(&quot;PoP&quot; || mvk),mvk)</code> and …\nCollects and returns the winning indices.\nFinalize the key registration. This function disables …\nCompare two <code>SingleSignature</code> by their signers’ merkle …\nCompute the <code>AggregateVerificationKey</code> related to the used …\nCompute the <code>AggregateVerificationKey</code> related to the used …\nA basic signature generated without closed key …\nWill be deprecated. Use <code>basic_verify</code> instead.\nCreates a new basic signer that does not include closed …\nBuild the <code>avk</code> for the given list of parties.\nGiven a slice of <code>sig_reg_list</code>, this function returns a new …\nList of registered parties.\nList of registered parties.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert a secret key into an <code>MspPoP</code>. This is performed by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert a secret key into an <code>MspMvk</code>. This is performed by …\nConvert a secret key into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an aggregate signature type from a prefix byte.\nExtract an aggregate signature from a byte slice.\nDeserialize a byte string to a <code>PublicKeyPoP</code>.\nConvert a string of bytes into a <code>MspSig</code>.\nConvert a string of bytes into a <code>SigningKey</code>.\nConvert a compressed byte string into a <code>VerificationKey</code>.\nDeserialize a byte string to a …\nExtract the <code>Parameters</code> from a byte slice.\nConvert a slice of bytes to an <code>Initializer</code>\nExtract a batch compatible <code>SingleSignature</code> from a byte …\nExtract a <code>SingleSignatureWithRegisteredParty</code> from a byte …\nCreate a new <code>Clerk</code> from a closed registration instance.\nCreate a Clerk from a signer.\nGenerate a secret key\nThe prefix byte used in the byte representation of the …\nGet closed key registration\nGet Parameters\nGet the (VK, stake) of a party given its index.\nGet the (VK, stake) of a party given its index.\nExtract stake from the signer.\nExtract the verification key.\nExtract the verification key with proof of possession.\nThe index(es) for which the signature is valid\nThe index(es) for which the signature is valid\nInitialize an empty <code>KeyRegistration</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nQuorum parameter.\nQuorum parameter.\nSecurity parameter, upper bound on indices.\nSecurity parameter, upper bound on indices.\nUnique public key out of the key registration instance.\nUnique public key out of the key registration instance.\nSetup a basic verifier for given list of signers. * …\nBuilds an <code>Initializer</code> that is ready to register with the …\nCreate a new <code>Clerk</code> from a closed registration instance.\nCreate a Clerk from a signer.\nCreates a new basic signer that does not include closed …\nBuild the <code>avk</code> for the given list of parties.\nCurrent protocol instantiation parameters.\nCurrent protocol instantiation parameters.\n<code>f</code> in phi(w) = 1 - (1 - f)^w, where w is the stake of a …\n<code>f</code> in phi(w) = 1 - (1 - f)^w, where w is the stake of a …\nProof of Possession.\nProof of Possession.\nProof of Possession.\nOrdered list of registered parties.\nOrdered list of registered parties.\nRegistered party\nRegistered party\nVerify and register a public key and stake for a …\nGiven a slice of <code>sig_reg_list</code>, this function returns a new …\nCreate a core signer (no registration data) for given input\nCreate a Signer for given input\nSetup a basic verifier for given list of signers. * …\nBuilds an <code>Initializer</code> that is ready to register with the …\nStm signature\nStm signature\nThe signature from the underlying MSP scheme.\nThe signature from the underlying MSP scheme.\nSign a message with the given secret key\nThis function produces a signature following the …\nMerkle tree index of the signer.\nMerkle tree index of the signer.\nThis participant’s stake.\nThis participant’s stake.\nConvert an aggregate signature to bytes\nConvert to a 96 byte string.\nConvert an <code>Signature</code> to its compressed byte representation.\nConvert the secret key into byte string.\nConvert an <code>VerificationKey</code> to its compressed byte …\nConvert to a 144 byte string.\nConvert to bytes\nConvert to bytes\nConvert an <code>SingleSignature</code> into bytes\nConvert <code>SingleSignatureWithRegisteredParty</code> to bytes\nIf the aggregate signature is a concatenation proof, …\nTotal stake of registered parties.\nTotal stake of registered parties.\nTotal stake of the registered parties.\nTotal stake of the registered parties.\nExtract the verification key.\nExtract the verification key.\nCore verification\nVerify an aggregate signature\nVerify a signature against a verification key.\nVerify an stm signature by checking that the lottery was …\nVerify a set of signatures with their corresponding …\nThe verification key.\nThe verification key.\nThe verification key.")